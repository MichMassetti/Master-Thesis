%% LaTeX2e class for student theses
%% sections/content.tex
%% 
%% Karlsruhe Institute of Technology
%% Institute of Information Security and Dependability (KASTEL)
%%
%% Template by
%% Dr.-Ing. Erik Burger
%% burger@kit.edu
%%
%% Adaption by
%% Annika Vielsack
%% vielsack@kit.edu
%%
%% Version 1.0, 2021-07-03
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\chapter{Preliminary Knowledge}
\label{ch:Backgroud}

The following sections are addressed to provide an introduction to the topics involved in our work: Ethereum, smart contracts and security techniques.
These are necessary for understanding specific security vulnerabilities and the results obtained from our experiment.
We recommend the reading of this chapter for those who are not keen on these topics, otherwise, the reader can directly jump at \autoref{ch:Exploits}.

\section{Blockchain}
\label{sec:Backgroud:Bitcoin}
This has the role of an umbrella term to encompass multi-party 
systems that operate in an environment with no central authority, despite parties who may be 
unreliable or malicious. 

Blockchain technology is a specific subset of the broader DLT universe that uses a 
particular data structure consisting of a chain of hash-linked blocks of data.
It contains a complete history of all data transfers and transactions that have ever taken place since it was first created.
In other terms, it keeps a collection of records called blocks that are constantly expanding.
One of the characteristics is the possibility to generate a digital currency. 
A cryptocurrency can be defined as a  medium of exchange secured by the ledger.
A medium of exchange is anything widely accepted as payment for goods and services, and a ledger is a data store that keeps track of transactions. 
Most blockchains implement a cryptocurrency by design, called "native token". 
For example, BTC is the native token of Bitcoin, ETH is the one of Ethereum, AVAX for Avalanche and so on.
\begin{figure}
    \centering
    \includegraphics[width=15cm]{logos/SimplifiedBlockChain.png}
    \caption{Simplified blockchain (image from \cite{BlockChain1}).}
    \label{fig:simpleBlockChain}
\end{figure}



The term "blockchain" is formed by "block", which refers to state and data being stored in consecutive groups, and "chain", 
which describes how each block contains a cryptographic reference to its parent. 
\begin{figure}
    \centering
    \includegraphics[width=10cm]{logos/tx-block.png}
    \caption{Change state overview(image from \cite{EthDocs}).}
    \label{fig:changeState}
\end{figure}

Blocks are collections of transactions that have the hash of the block before them in the chain.
Because hashes are cryptographically formed from the block data, this connects blocks.
Because any alteration to any historical block would render all subsequent hashes incorrect and cause everyone using the blockchain to become aware of it, this prevents fraud. 
These concepts are shown, in a simplified version, by \autoref{fig:simpleBlockChain}. Each block contains a list of transactions and keeps the reference to the previous one.

Transactions (\autoref{fig:transactionsBlockChain}) are cryptographically signed instructions from accounts, which are entities, having the possibility to get a balance and interact with the system. 
Accounts can be user-controlled or deployed as smart contracts.

\begin{figure}
    \centering
    \includegraphics[width=10cm]{logos/Transactions.png}
    \caption{Trasnactions scheme (image from \cite{BlockChain1}).}
    \label{fig:transactionsBlockChain}
\end{figure}

An account will initiate a transaction to update the state of the network. 
These are collected and stored in blocks, which then are broadcasted in the network. 
When this happens, a change in the state of the chain is applied (\autoref{fig:changeState}). 
This procedure, firstly the storing of transactions in blocks, and then those are the ones broadcasted on the net, 
is due to the fact the state of the blockchain is kept in the blocks, and not in the transactions.

The entities, the computers, taking part in the network, are called "nodes". 
Each of those must agree upon each new block and the chain as a whole. 
Nodes guarantee that everyone using the blockchain has access to the same data.

A consensus mechanism is required for blockchains to implement this distributed agreement. 
It is fundamental for creating agreement within the network and defines 
which node is the blocks are published in the network.

Following the survey of \citet{BlockChain1}, we can depict four main characteristics of this technology:
\begin{itemize}
    \item decentralization, due to the absence of third party control;
    \item persistency, because of the impossibility to delete or modify any transactions once they are stored in the ledger;
    \item anonimity, regarding the cryptographic aspects, such as the asymmetric key 
    and the hashing of blockchain data;
    \item auditability, that means that each pear can verify by itself the validity of block verification.
\end{itemize}


\subsection{Smart Contracts}

Smart Contract is a concept which is directly associated with blockchain, and specifically with Ethereum.
However, its concept was defined even before the first blockchain, in the 1994 by \citet{SmartContractDef}.
Its goal is to encode and enforce the entire logic that governs an interaction
between two (or more) mutually distrustful parties. By design it is autonomous, so it can be seen like a piece of software, made by codes.
Its strenght is the possibility to play the role of a trusted intermediary between distrusting parties
without being an actual party itself.
Blockchains are the first platform that allow the actual realization of
Smart Contracts without a trusted third party. 

The main limitation of those deals with their their inability to send HTTP requests, which is defined by desing. 
Basically, those cannot get information about "real-world" events on their own. 
The main reason of that involves that relying on external information could undermine consensus, which is vital for security and decentralisation. 

More limitations are introduced based on the blockchain, for example Bitcoin does not allow an arbitrary behaviour and the size of those is reduced, 
considering other systems, as Ethereum, which gives much more freedom of operability.

\section{Ethereum}
\label{sec:Backgroud:Ethereum}

Ethereum is a blockchain that was developed by \citet{Ethereum}, presented in the 2014. 
A single, canonical computer (known as the Ethereum Virtual Machine, or EVM) exists in the Ethereum universe, and everyone on the Ethereum network agrees on its current state.
Every Ethereum node, or participant in the network, maintains a copy of this computer's state. 
\autoref{fig:evm} illustrates a schematic representation of the EVM, underlying the common aspects with a computer, as the stack, memory, the storace, the EVM code (the smart contracts) and so on.


\begin{figure}
    \centering
    \includegraphics[width=13cm]{logos/evm.png}
    \caption{Diagram of EVM (image from \cite{EthDocs})}
    \label{fig:evm}
\end{figure}

The blockchain, which is saved and approved by all nodes, keeps track of all transactions and the current state of the EVM. 
Once a transaction is confirmed as genuine and put to the blockchain, cryptographic methods ensure that it cannot be changed later.
The same procedures guarantee that every transaction is signed and carried out with the necessary "permissions." 

Its consensus mechanism is defined as "proof of work" (PoW). 
It provides the rules for defining the node, which gets the responsability, and consequent rewards, of collecting the 
transaction, generating a block and broadcast it. 
Those nodes are called "miners", due to the mining, which is the process of creating a block of transactions to be added to the Ethereum blockchain. 

The nonce for a block must be discovered by miners through a rigorous process of trial and error under the proof-of-work protocol.
A block can only be added to the chain if it has a valid nonce. 
A miner who is frantically trying to make a block will continually run a dataset which can only be obtained by downloading and executing the entire chain—through a mathematical function.
According to the block difficulty, the dataset is used to build a mixHash below a target nonce.

In other words, the miners take part in this sort of race and the one who succedes to find the nonce, has the right to publish the block and get the rewards. 
Once generated, this is incredibly easy for other miners and clients to verify. 

The rewards involve the native token of the Ethereum: ether (ETH). 

\subsection{Ethereum Smart Contracts: Solidity}
\citet{EthDocs} describes its technology as a "Smart Contract Platform".
Those are described as programs that run on the Ethereum blockchain. 
Their codes and data are stored on the Ethereum blockchain, reachable at a specific address.
Since they are Ethereum account, they have a balance and can be the target of transactions. 

A smart contract can be created by anyone and released across the network.
Technically, deploying a smart contract counts as a transaction, so the deployment has a cost, called "gas fees".
Gas prices for contract deployment, however, are significantly higher. 

Those can be written in multple program languages defined by the Ethereum Foundation, which states that Solidity is the mostly used and mantained.
Its main features can be summarized as follow: 
\begin{itemize}
    \item object-oriented, high-level language for implementing smart contracts;
    \item statically typed (the type of a variable is known at compile time);
    \item curly-bracket language that has been most profoundly influenced by C++;
    \item the support of inheritance, libraries and complex user-defined types.
\end{itemize}

A particular type of function in Solidity is the "fallback", which is used even by attackers for malicious aims. 
Its characteristics are the following: 
\begin{enumerate}
    \item triggered when a non-existent function is called on the contract or when it receives a number of native tokens;
    \item it is marked as external (not callable by functions of the same contract);
    \item it has no name and arguments;
    \item the return value is empty;
    \item a contract can have just one of it;
    \item if not marked payable, it will throw an exception if the contract receives plain ether without data.
\end{enumerate}

The first property is fundamental in the case of "reentrancy" attacks. 
It occurs when the workflow of a smart contract is modified by an external call. 
Due to the fallback, the malicious external contract can modify the order of the execution of the target. 
An effective example occurs when a contract modifies the variable after the external call, so the malicious one can call back the same function (like recursion), 
but the variables are not updated. 

This thesis considers attacks that occurred even in other blockchains since those are defined as "EVM-compatible". 
That means the infrastructure of the systems has certain parts of the Ethereum network. 
This approach turned out to be beneficial for the developers of other blockchains, both in terms of time, knowledge transfer, and maybe most importantly interoperability. 
Having a code execution environment similar to Ethereum's Virtual Machines, Solidity is the programming language, 
consequently, same contracts can run on multiple blockchains.

\section{Application Domains}


Smart contracts technology gave the possibility to implement new financial instruments, 
based on their decentralised characteristic. 

Since the cryptographic aspects of the blockchain, it allows giving uniqueness to digital data thanks to the NFTs.

\paragraph{Decentralised Finance} Multiple investors have been attracted by new possibilities offered by "Decentralised Finance" (DeFi).
An article on the European Central Bank website (\cite{DeFiDef}) deepens this topic. The main strength of these financial instruments is the possibility to cut out traditional centralised intermediaries and rely on automated protocols instead. 
In this case, the investors are part of a peer-to-peer network where assets represented in the network can be transferred automatically, thanks to smart contracts.
In most cases, the DeFi applications do not provide new financial products or services but mimic within the crypto-asset ecosystem those provided by the traditional financial system.

Since there are not any legal regulations and many investments have been involved in DeFi, multiple malicious hackers have exploited this lack in their favour.

One of the targets of the attackers is a particular type of decentralized exchange (DEX) named autonomous market maker (AMM). 
\citet{AMMDef} presents it as a DEX based on a mathematical formula. Its peculiarity is how it estimates the asset price: according to a pricing algorithm.
It is considered autonomous and decentralised because the user does not need to have a counterparty (another trader) on the other side to make a trade. 
On the other hand, users directly interact with a smart contract that “makes” the market.

Since there are no counterparties, the market is generated by providing liquidity in the smart contract by the users forming liquidity pools (LPs).
First of all, liquidity, clarified by \citet{LiquidityDef}, is the measure of how easily you can convert an asset into cash or another asset. 
In other words, it depicts how the conversion of an asset into another one affects the price of the asset.
Liquidity is positively estimated when the asset's price is not easily affected by the transactions of the asset and the asset is easily sold and bought. 

A liquidity pool can be seen as a big pile of funds that traders can trade against. 
In return for providing liquidity to the protocol, LPs earn fees from the trades that happen in their pool.
For example, considering a token named MiTHC and ETH, a pool is generated associating an amount of MiTHC with an amount of ETH. 
If the pool is generated by 1000 MiTHC and 1 ETH, at that moment MiTHC value is 0.001 ETH.

\paragraph{NFT} Non-fungible tokens (NFTs) are cryptographic assets on a blockchain with unique identification codes and metadata that distinguish them from each other.
Unlike cryptocurrencies, they cannot be traded or exchanged at equivalency. 
This differs from fungible tokens like cryptocurrencies, which are identical to each other and, therefore, can serve as a medium for commercial transactions. 



\section{Security Analysis}
\label{sec:Backgroud:SecurityAnalysis}

Smart contracts are by design public and available by every account. 
In most cases, the code is published, otherwise, the bytecode is always available.
This aspect of the blockchain represents a drawback in sort of security because establishing security by layers scheme is impossible.
The developers cannot configure any sort of VPN (Virtual Private Network), Firewall or IDS (intrusion detection system). 
The attackers can directly access and interact with the smart contracts, consequently, the discovery of vulnerabilities turns into a challenge.
To fulfil this goal, multiple techniques have been adopted.


\paragraph{Fuzzing} \citet{OWASPFuzz} gives us an overview of this Black Box software testing technique. 
The goal is to find bugs, using random/semi-random data injection in an automated way. 

A fuzzer, which is the program implementing this, injects automatically the data, generated starting from a seed. The inputs depend on the generators. 
These can involve just a seed, or even static fuzzing vectors (known-to-be-dangerous values).
The number of possible solutions is infinite, consequently, fuzzers fix a threshold of cases.
One of the strengths of the systematic/random approach is to find bugs that would have often been missed by human eyes.

\paragraph{Formal Verification} Formal verification has the aim to prove or disprove the correctness of a system by checking its mathematical model
against a certain formal specification. A specification is a set of properties, which involve the
behaviours of the software. Models and specifications can regard different levels of abstraction via various types of formalisms.

\cite{FormalVerificationDef} explains that the absence of design flaws is not possible to prove, but the formal verification looks 
for the complete space of possible design behaviours which can be used to find and eliminate errors.

However, a drawback is that a timely solution is not always guaranteed in certain situations. It should have full coverage, but 
in real cases, the tools have a certain threshold considering time or an amount of computational effort.


\paragraph{Symbolic Execution} \citet{SymbolicExecution} provides a definition of this technique and its possible variations. 
Symbolic execution can be considered as a subgroup of Formal Verification. 
It is a program analysis technique to test
whether certain properties can be violated by a piece of software. 

The strength of symbolic execution is the simultaneous exploration of multiple paths
that a program could take under different inputs. This paves the road to sound analyses that can yield strong guarantees on the checked property. 
The key idea is to allow a program to take on
symbolic, rather than concrete, input values. 

Symbolic execution is less general than abstract interpretation because it does not explore all paths through the program. 
However, symbolic execution can avoid giving false warnings; any error found by symbolic execution represents a real and feasible path through the program, 
and a test case can illustrate that error.


\chapter{Real world Exploits}
\label{ch:Exploits}
\begin{center}

\begin{table*}
    \caption{Real World Exploits}
        \label{tab:RealWorldExploits}
        \begin{tabular}{cc}
        \toprule
            Real world exploits & Detail\\
            \midrule
            Aku & Funds stuck in the contract\\
            Cover & Wrong update of data\\
            BZX & Wrong implementation of token\\
            Spartan &  Bad estimation of rewards in a pool\\
            Uranium & Vulenrable depost withdraw process in a pool\\
            XSURGE &  Reentrancy in a token \\
            BurgerSwap &  Reentrancy in an AMM \\
            DirtyDogs &  Reentrancy in NFTs market \\
        \bottomrule
        \end{tabular}
    \end{table*}    
\end{center}

In this part of thesis, we introduce the objectives of the analyses: the real world exploits. 

\autoref{tab:RealWorldExploits} illustrates the attacks involve in our work, providing a brief description of those. 

This thesis involves real-world exploits that have been occurred two years ago, so 2020. 
Our choice tries to cover different aspects and the trend of the attacks. 
Our work involves the security of smart contracts, written in solidity. 
For having a wider overview of the topic, 
we decided not just to provide smart contracts deployed on the Ethereum chain, 
but even the ones deployed on other chains, specifically Avalanche and Binance Smart Chain. 
Those are still EVM-compatible blockchains. 

The picked attacks deal with significant projects, involving a great number of investments. 
The targets of attacks are not just autonomous money makers (AMM), but they can involve the implementation of a token or NFTs.

This chapter contains a subsection per each exploits. The general structure of those involves the following three main points:
\begin{enumerate}
    \item the explanation of the protocol;
    \item the exploit;
    \item the properties involved in the attack.
\end{enumerate}
The first part gives a general overview of the smart contract, 
defining its goals and main characteristics. 
After that, we present the exploit, illustrating the vulnerable part of the source code and the adopted strategies 
by the attackers.
In conclusion, the depicted properties are involved in drawing the specification of the tools.



\section{\$34 Million stacks NFT Project Aku Dreams Smart Contract}
\label{sec:Exploits:AkuDreams}
\citet{NFTValue} estimates the value of NFT market around \$100 billion.
Nowadays, the word NFT is one of the most researched ones on Google and the other search engine.
NFT's marketplaces manage the transaction behind these valuable markets. 
They are made by a frontend part, but even by a backend one which relies on the blockchain. 

\citet{Aku} reports Akutarts locked up \$34 million due to the faulty code of the smart contract.
The launch contained 15,000  NFTs and was based on the Dutch auction. This strategy involves a descending price auction where an item begins at a set maximum price. 
The price is gradually lowered over a fixed time until a bid is placed that guarantees the bidder to purchase the item at the current price. 
Anyone who paid the higher amount would get a refund.
Unfortunately, the launch was corrupted, since the errors in the codes made the project open to exploits. 
An attacker could block the withdrawals and refunds while attempting to highlight the vulnerabilities within the project.

\subsection{The exploit}
\label{sec:AkuDreams:AkutarsExploit}

The first part of the exploit involved the function processRefunds \autoref{lst:AkuDreamsProcessRefunds}.

This has the aim to refund the bid of the user who took part in the auction. 

The problem relies on the for loop in line 11. 
It loops on all over the users, who need to be refunded, estimating the number of tokens to send. 
Then, the amount is sent with the function call, which returns a boolean, based on the correct execution of the operation.

The problem relies on the "require" in the loop. If one of the accounts could not receive the refund, the function would always revert.
Since looping all over the users is a sequential operation, if the transaction just reverted when it reaches an item, it would never reach all the following items. 

Therefore, a malicious user just implemented a smart contract which took part in the auction and reverted any time it received tokens.

\begin{lstlisting} [language={Solidity},caption={Function for refunding the users.}, label={lst:AkuDreamsProcessRefunds}]
    function processRefunds() external {
      ...
      for (uint256 i=_refundProgress; gasUsed < 5000000 && i < _bidIndex; i++) {
          bids memory bidData = allBids[i];
          if (bidData.finalProcess == 0) {
            ...
            if (refund > 0) {
                (bool sent, ) = bidData.bidder.call{value: refund}("");
                require(sent, "Failed to refund bidder");
            }
          }
          ...
          _refundProgress++;
      }
      refundProgress = _refundProgress;
    }
\end{lstlisting}
The second part of the exploit is characterized by a bug in the logic, which could not allow the developer team to withdraw the project funds. 

The function claimProjectFunds (\autoref{lst:AkuDreamsClaim}), is callable only by the owner of the contract due to the modifier onlyOwner, 
refunds the developers just when all the users are considered refunded. 

The boolean condition, contained in the "require" in the first line of the function, is the heart of the problem. 
The "require" compares the variable refundProgress, which takes track of the refund progress, 
and totalBids.
\begin{lstlisting} [language={Solidity},caption={Function for claiming the funds for the developers.}, label={lst:AkuDreamsClaim}]
    function claimProjectFunds() external onlyOwner {
        require(refundProgress >= totalBids, "Refunds not yet processed");

        (bool sent, ) = project.call{value: address(this).balance}("");
        require(sent, "Failed to withdraw");        
    }
\end{lstlisting}

The variable totalBids is increased every time a bid is placed, regardless of the user who computed it, shown in \autoref{lst:AkuDreamsBid} .
The user can call the function \_bid, for placing a bid, with an arbitrary amount of bids, but the variable refundProgress is increased every time a user is refunded. 
Consequently, if a user bought more than one bid, the amount of refounded users would never be greater or equal to the number of placed bids.
\begin{lstlisting} [language={Solidity},caption={Function for users'bid}, label={lst:AkuDreamsBid}]
    function _bid(uint8 amount, uint256 value) internal {
        ...
        uint256 myBidIndex = personalBids[msg.sender];
        ...
        if (myBidIndex > 0) {
            myBids = allBids[myBidIndex];
            refund = myBids.bidsPlaced * (myBids.price - price);
        }
        ...
        uint256 _totalBids = totalBids + amount;

        if (myBidIndex > 0) {
            allBids[myBidIndex] = myBids;
        } else {
            myBids.bidder = msg.sender;
            personalBids[msg.sender] = bidIndex;
            allBids[bidIndex] = myBids;
            bidIndex++; //bidIndex updated just when a new user computes a bid
        }
        totalBids = _totalBids; //totalBids depends on the amound of bids
        ...
    }
\end{lstlisting}

\subsection{Properties}
The smart contract involves 2 main problems: the refunding of the users who placed the bids and the claim of the developers' rewards.

The first property deals with the function processRefunds. 
It reverts every time because a malicious wallet, which cannot receive 
any tokens triggering the "require". 
We verify if the contract can always refund all the users.
The property involves the sum of refunded wallets may be equal to the number of the counter which loops on the map containing the data. 
It is a postcondition, so it is proven that all the users are refunded if the function does not revert, which means that the function does not 
consider the case of error.

The other property regards the function claimProjectFunds. 
In the beginning, some requirements have to be fulfilled before the owner can obtain the rewards.
Our focus is on the comparison between the counter of the refunded users and the total amount of bids.
In this case, we use proof by contradiction. We check if the processRefunds variable is always less than the totalBids. 
The property should be proofed if we consider that at least one user placed more than one bid.

Property 1 postcondition refered to function processRefunds():
\begin{equation}
      \_refundProgress<=\_bidInd
\end{equation}

Property 2 precondition referred claimProjectFunds() : 
\begin{equation}
    refundProgress >= totalBids
\end{equation}

%Bug in the code, storage and memory solidity kew word 
\section{Cover Protocol:Infinite Minting Exploit Nets Attacker \$4.4M }
\label{sec:Exploits:CoverProtocol}
In December 2020, an exploit was abused on Cover Protocol's shield 
mining contract. 
The article shows the attackers could steal from project around \$ 4 million. 
The target of the attack was the smart contract "Blacksmith.sol", available on GitHub \url{https://github.com/CoverProtocol/cover-token-mining/blob/main/contracts/Blacksmith.sol}, its bug had the result to mint more rewards to the miner. 

\citet{CoverProtocol} interviewed the co-founder of the Cover Protocol. In his article, he answers some questions about his project, regarding its functionality and road map. 
It was an active protocol on the Ethereum blockchain; the developer deployed version 2,  because of the attack. 
Cover Protocol is a peer-to-peer coverage marketplace that utilizes ERC-20 fungible tokens to allow permissionless and non-KYC coverage. 
It can be described as a coverage provider.
The attack affected the rewards contract, consequently, the token's one even.  
The exploit can be classified under the name of "infinite mint".

\subsection{The exlpoit}
\label{sec:CoverProtocol:Exploit}
The developers' team reported \citep{CoverProtocolPostMortem} the technical analysis of the exploit the day after.
The core protocol was not affected, 
but the minting contract and the \$COVER token became unusable.
Firstly, the attackers created a new balancer liquidity pool for the target contract. The next step was to deposit tokens in it and execute the exploit, 
withdrawing funds from the contract thanks to a miscalculation of the rewards.
The bug relies on the misuse of two keywords in solidity: storage and memory. 

\paragraph{Memory} This keyword within Solidity allocates memory for a specific variable. 
In this instance, that variable is scoped to a specific function. 
The memory is cleared once the function has executed.

\paragraph{Storage} On the other hand this keyword within Solidity allows variables to act as a pointer into the storage of data in mappings or data structures. 
Storage data is persistent between function calls and transactions. 

The previous has a similar behave to the Random Access Memory (RAM) on a computing device, the latter stores into the persistent memory.

The vulnerable function is the deposit one.

\begin{lstlisting} [language={Solidity},caption={Deposit function.}, label={lst:coverdeposit}]
    function deposit(address _lpToken, uint256 _amount) external override {
        ...
        Pool memory pool = pools[_lpToken];
        updatePool(_lpToken);

        Miner storage miner = miners[_lpToken][msg.sender];
        BonusToken memory bonusToken = bonusTokens[_lpToken];
        _claimCoverRewards(pool, miner);
        _claimBonus(bonusToken, miner);
        // variable pool is not updated
        miner.rewardWriteoff = miner.amount.mul(pool.accRewardsPerToken).div(CAL_MULTIPLIER); 
        ...
  }
\end{lstlisting}
\autoref{lst:coverdeposit} shows the state of the pool is stored in a variable with the keyword memory. 
The function update updates the state of the pool. 
However, the variable pool, existing within the function, remains identical. 

The function estimates the reward per token updating the value of miner.rewardWriteoff, 
but it uses the wrong value of the parameter of pool.accRewardsPerToken.

Following the vulnerability, anyone can obtain an insane amount of minted tokens when they execute the claimRewards(address \_lpToken) function. 
This function, which is used to grab their rewards, ends up calling \_claimCoverRewards(Pool memory pool, Miner memory miner) 
which references the miner.rewardWriteoff. 
As that variable is much smaller than the actual pool.accRewardsPerToken, the contract results in minting an abundance of tokens.

\subsection{Properties}
The heart of the problem is the wrong management of the keywords storage and memory. 

The consequence of this error is a miscalculation of the reward of the miner.
The property relies on how it is computed. It is not estimated considering the correct parameters of the pool. 



We compare the miner.rewardWriteoff with its recompute mathematical value with the updated parameters, 
right after the execution of the function. 
\begin{equation}
    \begin{split}
    miner.rewardWriteoff == miner.amount.mul(pool.accRewardsPerToken) \\ .div(CAL\_MULTIPLIER)
    \end{split}
\end{equation}

The post-condition involves the estimation of the reward inside the function deposit.

\section{DeFi platform bZX: \$8M hack from one misplaced line of code}
\label{sec:Exploits:bZX}

\citet{bZxProtocol} explains how this protocol works. 
Anyone can use bZx to create apps that allow lenders, borrowers, and traders to interact with Ethereum based 
decentralised finance protocol.

Protocols can be developed by bZx. 
It is a powerful DeFi platform for tokenized lending and margin trading. 
iTokens (margin loans) represent the earn holders' interest on borrowed funds allowing margin positions to be composable.

Unfortunately, it suffered a couple of attacks in February 2020.
The developers explained the attackers could drain different currencies,219,199.66 LINK, 4,502.70 Ether (ETH), 1,756,351.27 Tether (USDT), 
1,412,048.48 USD Coin (USDC) and 667,988.62 Dai (DAI): a total of \$8 million in value. 

\subsection{The exploit}

The object of the attack was the contract named LoanTokenLogicStandard.
It implements the logic behind the protocol.
Every ERC20 token has a transferFrom() function, which has the aim to transfer the tokens.
Calling this function allowed the attacker to create and transfer an iToken to hitself: his balance could be artificially increased.
The duplicated tokens were then redeemed for their underlying collateral, 
with the hackers now “owning” a much higher percentage of the pool, so the attacker could withdraw the tokens.

\autoref{lst:internalTransferFrom} shows the vulnerable function. 
The attacker called the function with the same amount of \_from and \_to. 
Since both addresses refer to the same one, line 27 decreases the balance of the address, but then line 31 increases the same balance. 
The problem relies on the estimating of the amount: it is the sum of the sent token and 
a variable, which stored the value of the balance before the transaction.

\begin{lstlisting} [language={Solidity},caption={Vulnerable function in LoanTokenLogicStandard contract.}, label={lst:internalTransferFrom}]
    ... 
    function _internalTransferFrom (address _from, address _to, uint256 _value, uint256 _allowanceAmount)
        internal
        returns (bool)
    {
        //The heart of the vulnerability 
        uint256 _balancesFrom = balances[_from];
        uint256 _balancesTo = balances[_to];

        require(_to != address(0), "15");

        uint256 _balancesFromNew = _balancesFrom
            .sub(_value, "16");
        balances[_from] = _balancesFromNew;

        uint256 _balancesToNew = _balancesTo
            .add(_value);
        balances[_to] = _balancesToNew;
        ...
    }
\end{lstlisting}

The developers corrected the bug in few days. 
It was enough switching some lines of code, in order to avoid the operations of sum and subtraction operate on the same balance. 
The code \autoref{lst:CorrectinternalTransferFrom} presents some differences. The operations regarding the receiver's balance are computed, then those which deal with the sender's one (16-20).
\begin{lstlisting} [language={Solidity},caption={Corrected bug in LoanTokenLogicStandard contract.}, label={lst:CorrectinternalTransferFrom}]
    function _internalTransferFrom(address _from, address _to, uint256 _value, uint256 _allowanceAmount)
        internal
        returns (bool)
    {
        ...
        require(_to != address(0), "15");
        uint256 _balancesFrom = balances[_from];
        uint256 _balancesFromNew = _balancesFrom
            .sub(_value, "16");
        balances[_from] = _balancesFromNew;
        uint256 _balancesTo = balances[_to];
        uint256 _balancesToNew = _balancesTo
            .add(_value);
        balances[_to] = _balancesToNew;
        
        return true;
    }   
\end{lstlisting}

\subsection{Properties}
The function internalTransfer is the one which contains the bug abused by the attackers. 
We define 2 properties for defining the correct execution of the function. Both of those are broken by 
the wrong implemntation of the function.

The first one is a post-condition. It involves the correct estimation of the balance of the addresses involved in the operation, the parameters from and to.
The balance of the sender should decrease and the one of the receiver should increase.
\begin{equation}
    \begin{split}
        old\_value\_of(balances[\_from])>=balances[\_from] \\
        \&\&old\_value\_of(balances[\_to])<=balances[\_to]
    \end{split}
\end{equation}
The other one is an invariant. It states the total sum of balances should be less than the variable total supply. 
\begin{equation}
    sum_of_uint(balances) <= totalSupply
\end{equation}


\section{A flash loan used for amplify a bug: \$30M  drained from Spartan protocol}   
\label{sec:Exploits:Spartan}
Spartan Protocol is a DeFi protocol for synthetic assets running on BinanceSmartChain. 
It inherits many capabilities of UniswapV2 protocol, adapting the code for new use cases and implementing different strategies. 
The fee mechanism is modified to incentivize liquidity providers when liquidity is scarce. Consequently, users trading larger 
volumes are charged more fees. Similar to UniswapV2, pairs WBNB and SPARTA tokens are open for users to add/remove liquidity. 
For clarifying this, let's consider the following example. Bob can send (WBNB+SPARTA) into the WBNB-SPARTA pool and get Liquidity Pool (LP) tokens back, 
redeemable for the underlying assets.

This protocol was the target of an exploit at the end of May 2021.
The presence of a bug inside the code, plus the amplification due to a flash loan, allowed the attacker to drain the liquidity.

The articles \citetitle{FlashCoin} and \citetitle{FlashCloud} give a defintion flash loan.

\paragraph{Flash loan} A flash loan is a relatively new type of uncollateralized lending that has become popular across
several decentralized finance (DeFi) protocols based on the Ethereum network. 
When it has been issued, the smart contract certifies that the borrower pays back the loan before the transaction ends. 
If this condition is not fulfilled, the transaction reverts, consequently, the amount of the loan is given back. 

\subsection{The exploit}
\label{sec:Spartan:Exploit}
The exploit involved 2 contracts of protocol: Utils.sol and poolFactory.sol.
The latter implements the strategy for the management of the liquidity in the pool and the former provides support functions. 
The mistake of the developers was not to consider the updated value of underlying assets. 
Those are stored into the variables (baseAmount, tokenAmount) and estimated with iBEP20(token).balanceOf(pool) and iBEP20(base).totalSupply().

The bug in code lies in the calcLiquidityShare() function, called in RemoveLiquidity(). 
\begin{lstlisting} [language=Solidity, caption={calcLiquidityShare function}, label={lst:calcLiquidityShare}]

    function calcLiquidityShare(uint units, address token, address pool, address member) public view returns (uint share){
        // share = amount * part/total
        // address pool = getPool(token);
        uint amount = iBEP20(token).balanceOf(pool);
        uint totalSupply = iBEP20(pool).totalSupply();
        return(amount.mul(units)).div(totalSupply);
    }

\end{lstlisting}

It should get the balance of the underlying asset in the pool (\autoref{lst:calcLiquidityShare}). 
The amount that which should be transferred out is calculated based on the total LP tokens supplied
and the number of LP tokens to burn (units).
The function does not consider who transfers assets into the pool. The value of underlying assets can be manipulated and increased by an exploit. 
The real values are different from the ones contained in the variable (baseAmount, tokenAmount).
The removeLiquidity() calls calcLiquidityShare on TOKEN and BASE(\autoref{lst:SpartanRLM}). 
It fails to synchronize the balances of the underlying assets and the variables which store the amount of the assets.

\begin{lstlisting} [language=Solidity, caption={Function for Removing Liquidity}, label={lst:SpartanRLM}]
    // Remove Liquidity for a member
    function removeLiquidityForMember(address member) public returns (uint outputBase, uint outputToken) {
        uint units = balanceOf(member);
        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityShare(units, BASE, address(this), member);
        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityShare(units, TOKEN, address(this), member);
        ...
        return (outputBase, outputToken);
    }
\end{lstlisting}
As a consequence, the \_decrementPoolBalance(), updates the  wrong value of the variables storing the assets. 
It does not get the update-to-date balances of BASE and TOKEN. Instead, it only decrements the reserved amounts (baseAmount, tokenAmount).
The attacker followed these steps for draining the liquidity:
\begin{enumerate}
    \item Add liquidity and get LP tokens back.
    \item Transfer some assets into the Pool contract to amplify the number of underlying assets of the LP tokens collected in step 1.
    \item Remove liquidity and get more assets than what you added in Step 1.
    \item Add the assets transferred into the Pool contract as liquidity and remove them immediately.
\end{enumerate}

\begin{lstlisting} [language=Solidity, caption={Function which updates decrements the assets in the pool.}, label={lst:SpartanFunc}]
    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {
        
        uint _removedBase = iUTILS(_DAO().UTILS()).calcShare(_baseAmount, baseAmount, baseAmountPooled);
        uint _removedToken = iUTILS(_DAO().UTILS()).calcShare(_tokenAmount, tokenAmount, tokenAmountPooled);
        baseAmountPooled = baseAmountPooled.sub(_removedBase);
        tokenAmountPooled = tokenAmountPooled.sub(_removedToken); 
        //Wrong Estimation of these 2 variables
        baseAmount = baseAmount.sub(_baseAmount);
        tokenAmount = tokenAmount.sub(_tokenAmount); 
    }
\end{lstlisting}
A solution for this bug is shown in \autoref{lst:SpartanSync}. It updates the variables of assets before it is estimating the 
the amount to drain.
\begin{lstlisting} [language=Solidity, caption={Possible corrcet calcLiquidityShare.}, label={lst:SpartanSync}]
    function calcLiquidityShareSynch(uint units, address token, address pool, address member) public view returns (uint share){
        // synchronize the variable
        iPOOL(pool).sync();  
        uint amount = iBEP20(token).balanceOf(pool);
        uint totalSupply = iBEP20(pool).totalSupply();
        return(amount.mul(units)).div(totalSupply);
    }

    function sync() public {
        baseAmount = iBEP20(BASE).balanceOf(address(this));
        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));
    }
\end{lstlisting}

\subsection{Properties}
The issue correlated to the logic of the program involves the removing liquidity process. 
The attacker could amplify the number of tokens to remove.

The function calcLiquidityShare is an internal function which estimates the total of underlying assets to send to the user. 
It miscalculates the value because it considers the balance of the account, which can be simply modified by transferring tokens into the pool.
A proposed solution implies a function, synch, which synchronises the variables baseAmount and tokenAmount, which keep track of the underlying assets in the contract. 
Function synch should be called in the buggy function.

This one is encompassed in the definition of the property. 
It is called the end of the process of removing the liquidity for a member. 
The postcondition specifies that the function synch should not update the two variables.  

\begin{equation}
    \begin{split}
        no modifies baseAmount, tokenAmount
    \end{split}
\end{equation}

Another way for checking the property would be checkig if the estimated returned value of the function calcLiquidityShare(...) uses the correct parameters.

\begin{equation}
    \begin{split}
        iBEP20(token).balanceOf(pool) == baseAmount \\
        || iBEP20(token).balanceOf(pool) == tokenAmount
    \end{split}
\end{equation}

\section{Uranium Finance: \$1.3M of rewards drawn}   
\label{sec:Exploits:Uranium}
Uranium Finance is a Automated Marker Maker (AMM) runnning on the BinanceSmartChain.
The article presented by \citet{UraniumPM}, deals wiht the exploit which occured on the 
8th April 2021. The attacker could grab the contents of the RADS pool and all of the RADS/sRADS rewards 
and sell them for \$1.3M worth of BUSD and BNB.

The team of developer could identify the exploiter, because some transaction of the attacker wallet, could be 
correleted with a Binance wallet. The criminal got in touch with the developers. After some negotiation, 
the exploiter refund the team of \$1M in ETH.

\subsection{The exploit}
\label{sec:Uranium:Exploit}


The article written by \citeauthor{UraniumTech}, gets more in deep into the technical details involved in this exploit.
The target of it was the contract \href{https://bscscan.com/address/0xd5aac41d315c1d382dcf1c39d4ed9b37c224edf2#code}{MasterUranium}, specifically the part regarding the rewarding of the user.
The list of transactions involving the malicious wallet shows the attacker could draw a huge amount of rewards 
by calling 3 functions multiple times:
\begin{enumerate}
    \item deposit(\_pid, \_amount); 
    \item emergencyWithdraw(\_pid); 
    \item withdraw(\_pid, \_amount).
\end{enumerate}


\paragraph{Deposit} The two most relevant variables to the exploit are user.amountWithBonus and user.rewardDebt, for the attack purpose, they need to be greater than 0.
Therefor this function is called with  with the \_amount input argument larger than “0”. 

The user.amountWithBonus increases by adding  
the \_bonusAmount. 
The user.rewardDebt is calculated by the end of the function, with
user.rewardDebt = 
user.amountWithBonus.mul(pool.accRadsPerShare).div(1e12).
When the function returns, the  both variables are greater than 0.

\begin{lstlisting} [language=Solidity, caption={Deposit Function}, label={lst:UraniumDeposit}]
    function deposit(uint256 _pid, uint256 _amount) external validatePool(_pid) {
        ...
        if (_amount > 0) {
            pool.lpToken.safeTransferFrom(address(_user), address(this), _amount);
            if (address(pool.lpToken) == address(rads)) {
                uint256 transferTax = _amount.mul(2).div(100);
                _amount = _amount.sub(transferTax);
            }
            //The bonus increase
            if (pool.depositFeeBP > 0) {
                ...
                uint256 _bonusAmount = _amount.sub(depositFee).mul(userBonus(_pid, _user).add(10000)).div(10000);
                user.amountWithBonus = user.amountWithBonus.add(_bonusAmount);
                pool.lpSupply = pool.lpSupply.add(_bonusAmount);
            } else {
                user.amount = user.amount.add(_amount);
                uint256 _bonusAmount = _amount.mul(userBonus(_pid, _user).add(10000)).div(10000);
                user.amountWithBonus = user.amountWithBonus.add(_bonusAmount);
                pool.lpSupply = pool.lpSupply.add(_bonusAmount);
            }
        }
        user.rewardDebt = user.amountWithBonus.mul(pool.accRadsPerShare).div(1e12);
        emit Deposit(_user, _pid, _amount);
    }

    // Withdraw LP tokens from MasterUranium.




\end{lstlisting} 

\subparagraph{EmergencyWithdraw} 
The next step is the withdrawal of the funds. 
This function has the purpose of getting the deposited token back and setting user.amount equal to and user.rewardDebt equal to 0.
The fundamental variable user.amountWithBonus is still larger than 0. It is exploited during the last step.

\begin{lstlisting} [language=Solidity, caption={Deposit Function}, label={lst:UraniumEMW}]
    // Withdraw without caring about rewards. BonusAmount is not updated
    function emergencyWithdraw(uint256 _pid) external {
        PoolInfo storage pool = poolInfo[_pid];
        UserInfo storage user = userInfo[_pid][msg.sender];
        pool.lpToken.safeTransfer(address(msg.sender), user.amount);
        emit EmergencyWithdraw(msg.sender, _pid, user.amount);
        user.amount = 0;
        user.rewardDebt = 0;
    }
    
\end{lstlisting} 

\subparagraph{Withdraw} In the last step, the attacker call this function with \_amount equal to 0.
LThe pending variable is estimeted, but the user.rewardDebt is equal to 0.
Since both pool.accRadsPerShare and user.amountWithBonus are positve number, the result is larger than 0 as well.
Since the amount is 0, the code cannot adjust the user.amountWithBonus variable to indicate the user claims the reward.

\begin{lstlisting} [language=Solidity, caption={Deposit Function}, label={lst:UraniumW}]
    function withdraw(uint256 _pid, uint256 _amount) external validatePool(_pid) {
       ...
        uint256 pending = user.amountWithBonus.mul(pool.accRadsPerShare).div(1e12).sub(user.rewardDebt);
        if(pending > 0) {
            if(pool.isSRadsRewards){
                safeSRadsTransfer(msg.sender, pending);
            }
            else{
                safeRadsTransfer(msg.sender, pending);
            }
        }
        if(_amount > 0) {
            user.amount = user.amount.sub(_amount);
            uint256 _bonusAmount = _amount.mul(userBonus(_pid, msg.sender).add(10000)).div(10000);
            user.amountWithBonus = user.amountWithBonus.sub(_bonusAmount);
            pool.lpToken.safeTransfer(address(msg.sender), _amount);
            pool.lpSupply = pool.lpSupply.sub(_bonusAmount);
        }
        user.rewardDebt = user.amountWithBonus.mul(pool.accRadsPerShare).div(1e12);
        emit Withdraw(msg.sender, _pid, _amount);
    }

\end{lstlisting} 

The user.amountWithBonus increases every time the attacker starts from the step 1. 
This enables the attacker to drains more and more tokens in the process. 
Checking the transcation on \href{https://bscscan.com/txs?a=0x36ad9ee78bfb730955993d2aa77ecccf95e3313e&p=3}{BSCscan}, it is shown how many times the attacker 
replicated this methodology. 

\subsection{Properties}
The logic of the smart contract vulnerability is contained in the procedure of estimation of users' rewards.

The malicious sequence of functions involves the call of deposit, emergencyWithdraw and withdraw.
Therefore, the attacker could get back the same amount of deposited tokens, but with a higher amount bonus for the reward. 
The parameter amountWithBonus of user struct, which keeps track of the amount and the bonus, just increases even if the user receives the reward and it is withdrawing. 

For the detection of the vulnerability, we specify the property as a postcondition of the function withdraw. 
\begin{equation}
    \begin{split}
        userInfo[msg.sender].bonus-userInfo[msg.sender].rewardDebt ->  
        \\userInfo[msg.sender].bonus < old_value_of(userInfo[msg.sender].bonus)
    \end{split}
\end{equation}

\section{XSURGE on BSC Chain}   
\label{sec:Exploits:XSURGE}
The \citet{XSurgeWeb}'s whitepaper provides a presentation of the ecosystem.
It is described as a great DeFi investing idea based on proprietary pricing algorithms embedded in the Surge Token Variants' contracts.
Surge Token Variants each have their own Market Maker, allowing them to trade continuously and outlast both 
centralised and decentralised exchanges. 
The strategy is to reward long-term holding by increasing a
holder's claim of the backing asset. Each Surge Token utilizes a built-in contract exchange system that renounces the need for
a traditional liquidity pool. Both assets are stored within the contract itself, 
rather than a liquidity pool pair of the backing asset to the
token using a traditional market maker method for exchange and price calculation.

\subsection{The explpoit}
One of the Surge Token is SurgeBNB, the one which is my focus of analysis.
\citet{XSurgeBNB} explains in deep how the attack to this contract occured. 
The team claimed that the attacker had stolen \$5 million in SurgeBNB through a backdoor vulnerability.
XSURGE stated that a potential security vulnerability in the SurgeBNB contract was discovered on August 16th.

The attack is mabe by 4 main steps:
\begin{enumerate}
    \item the attacker borrow  10,000BNB through flash loans.
    \item Use all the BNB to buy SURGE. According to the current price, 
    the attacker can buy 1,896,594,328,449,690 SURGE
    \item He calls the "sell" function, for selling the obtained SURGE.
    \item The sale function alters the data after the transfer, and the transfer code has a reentrance vulnerability.
    When the attack contract acquires BNB, the period before the SURGE contract's state changes 
    (\refname{lst:SellSURGE}), the attack contract can use the reentrance 
    vulnerability to purchase SURGE again.
\end{enumerate}

\begin{lstlisting} [language={Solidity},caption={Sell function of Surge (SURGE) token.}, label={lst:SellSURGE}]
    function sell(uint256 tokenAmount) public nonReentrant returns (bool) {
        ...
        //The reentrancy 
        (bool successful,) = payable(seller).call{value: amountBNB, gas: 40000}(""); 
        if (successful) {
            // subtract full amount from sender
            _balances[seller] = _balances[seller].sub(tokenAmount, 'sender does not have this amount to sell');
            // if successful, remove tokens from supply
            _totalSupply = _totalSupply.sub(tokenAmount);
        } else {
            revert();
        }
        
        return true;
    }
\end{lstlisting}


The bnb Amount of the contract stays intact, and the total amount of SURGE tokens \texttt{totalSupply}  
has not been updated, because the attack contract spends all of the BNB balance to acquire SURGE
 each time (still remains the quantity before the sell).
As a result, the price of token falls, allowing the attacker to purchase additional SURGE. 

Repeating three times of Round 2 and Round 3 , the attacker accumulates a large amount of SURGE through reentry, and then sells all the SURGE to make a profit.

At the end of this transaction, the attack contract sold 1,864,120,345,279,610,000 SURGE, 
obtained 10327 BNB, and finally the profitable 297 BNB was sent to the attacker's address.

The following are the modifications suggested by the Beosin technical team for this attack:
\begin{itemize}
    \item any transfer operation should be place after the state changes to avoid reentry assaults.
    \item Instead of using "call. value," use transfer or send to transfer. 
\end{itemize}

\subsection{Properties}

This exploit represents a typical case of reentrancy. 

The attacker's strategy involves the function sell, which contains the bug, and then the function purchase. 
After calling the first one and triggering the reentrancy, the malicious fallback implemented by the attacker uses the amount of money for buying more XSURGE tokens. 
At the end of the selling process, the total supply should decrease the amount sold by the user.
But since the attacker called the purchase, the variable is not updated as it was supposed to be. 
Buying the same amount of sold tokens, the value would not change.

We define the property as a postcondition,refered to the function sell(...), which states the variable \_totalSupply is decreased of the amount sold by the user, then tokenAmount.

\begin{equation}
    \begin{split}
        \_totalSupply <=old\_value\_of(\_totalSupply)
    \end{split}
\end{equation}

The properties can be even expressed like a an invariant, stating that the sum of the single balances cannot exceedes the variable \_totalSupply.
\begin{equation}
    \begin{split}
        sum_of_uint(_balances) <= _totalSupply
    \end{split}
\end{equation}

\section{Reentering the Reentrancy Bug: Disclosing BurgerSwap's Vulnerability}   
\label{sec:Exploits:BurgerSwap}
BurgerSwap is an automated Marker Maker service on Binance Smart Chain (BSC). 
At time of the disclosure of the vulnerability, there was areound \$13K worth of Ether at immediate risk.
The vulnerability was was presentend by \citet{BurgerSwap}.

It is a Binance Smart Chain fork of Uniswap, Automated Marker Maker (AMM) service operating on Ethereum. 
Tranding and listing Specialized BEP-20 tokens among standard swapping options are available on this platform. 
To mint such tokens, users can use 
BurgerSwap's “bridge” contract on Ethereum. 

\subparagraph{Brige} is a combination of 2 smart contracts deeployed on different chains. 
It allows cross-chain transfers of value. Ether deposited into the contract on 
the main net will provide a balance denominated in ERC-20 tokens on the sidechain. 
While ERC-20 tokens deposited back into the contract on the sidechain can free up Ether on main net.
One example could be locking Ether, which is converted via the contract to WETH 
(Wrapped Ether, an ERC-20 token pegged to Ether), and then the same wallet locking ETH can be credited with bWETH on BSC.

\subsection{The exploit}
\label{sec:BurgerSwap:Vulnerability}

The issue deals with the fucntion withdrawFromBSC, \autoref{lst:BurgerSwap}. 
First of all, it checks some conditions and then it proceedes to transfer the amount to the mseeage sender. 
The order of the actions is:
\begin{enumerate}
    \item It verifies executeMap[\_paybackId] is false;
    \item It checks \_signature is a valid signature on \_paybackId, \_token, msg.sender, and \_amount.
    \item It calls TransferHelper.safeTransferETH(msg.sender, \_amount).
    \item It sets executeMap[\_paybackId] to true.
\end{enumerate}

The issue is the interaction with the sender's address (step 3) happens before the internal effect (step 4): reentrancy is feasible.

\begin{lstlisting} [language=Solidity, caption={BugerSwap Bridge vulnerable function}, label={lst:BurgerSwap}]

    function withdrawFromBSC(bytes calldata _signature, bytes32 _paybackId, address _token, uint _amount) external payable {
        require(executedMap[_paybackId] == false, "ALREADY_EXECUTED");
        
        require(_amount > 0, "NOTHING_TO_WITHDRAW");
        require(msg.value == developFee, "INSUFFICIENT_VALUE");
        
        bytes32 message = keccak256(abi.encodePacked(_paybackId, _token, msg.sender, _amount));
        require(_verify(message, _signature), "INVALID_SIGNATURE");
        
        if(_token == WETH) {
            IWETH(WETH).withdraw(_amount);
            TransferHelper.safeTransferETH(msg.sender, _amount);
        } else {
            TransferHelper.safeTransfer(_token, msg.sender, _amount);
        }
        totalFee = totalFee.add(developFee);
        
        executedMap[_paybackId] = true;
        
        emit Withdraw(_paybackId, msg.sender, _token, _amount);
    }
    
\end{lstlisting}

Folowing the execution of the code, the bug is found in the safeTransferETH function, contained in TransferHelper library. 
The expression to.call{value:value}(new bytes(0)) is actually a call to the sender of the message, which can be an arbitrary smart contract. 
The malicious contract can implemnt a fallback function. By the time it receives the ether, the fallback function is 
triggered and withdrawFromBSC is run again, but without updating executeMap[\_paybackId]. 
Since it is not set to true, the code repeat the same sequence of operation. 
Repeating this process within the same transaction, the attacker will drain the vulnerable contract's WETH holdings and credit.

\subsection{Properties}
The keyword of this exploit is reentrancy. 

The smart contracts adopt an access control strategy at the beginning of the function, checking the signature of the user. 
The attacker forked MetaMask, a crypto-wallet, for allowing a smart contract to 
access the vulnerable function. However, it is out of our interest and we focus on the vulnerability in the code.

The vulnerable function is safeTransferETH, resonsable of sending ETH to the user. This is called by the one which manages 
the withdrawal of funds from the contract by the user. The malicous contract, 
thanks a fallback, can call multiple times the same function and withdrawing more money than it could.

With the postcondition, we check the balance of WETH (wrapped ETH) before and after the function, 
stating the difference should be the parameter amount of the function.

\begin{equation}
    \begin{split}
        old\_value\_of(address(this).balance) == address(this).balance - \_amount
    \end{split}
\end{equation}



\section{Infinite minting of NFTs: DirtyDogs NFTs}   
\label{sec:Exploits:DirtyDogs}

he project DirtyDogs implements a platform for buying and minting its collection of NFTs.
It implements the specific standard ERC721 for managing NFTs. 

The smart contract allows the users to buy the NFTs, before the official selling phase, buying a ticket, which would be used for minting those.
The protocol should keep track of the ticket for minting the correct number of NFTs.

\subsection{The exploit}
\label{sec:DirtyDogs:Exploit}
DirtyDogs NFT contract has a typical example of reentrancy.
The attacker exploited the function claimDogs(), shown in \autoref{lst:DirtyDogs}.
Firstly, the malicious wallet bought a ticket for having the right of receiving an NFT, calling the function claimDogs().
It loops on the number of tickets the sender has, and it calls the function \_safeMint for creating the NFTs and sending them to 
the caller.

The bug involves the update of the variable totalClaimed[\_msgSender()] at the end of the loop. It is the one which 
keeps track of the number of tickets owned by the caller.

The malicious smart contract implemented a 
callback function: the main trigger for reentrancy attacks. 
Within the same transaction, it gets the opportunity to execute the same code multiple times. 
When the smart contract receives an NFT, the fallback function is triggered and the claimDogs() function is called again. 
As result, the attacker could call again the function for mintining, but without updating the variable which counts the number of tickets per address.
The exploit produced 45 NFTs because the fallback has the risk of reverting, 
there is a limit of times to be called.

    
\begin{lstlisting} [language=Solidity, caption={DirtyDogs NFT contract}, label={lst:DirtyDogs}]
contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
        ... 
    function _mint(address to, uint256 tokenId) internal virtual {
        require(to != address(0), "ERC721: mint to the zero address");
        require(!_exists(tokenId), "ERC721: token already minted");
        _beforeTokenTransfer(address(0), to, tokenId);
        _holderTokens[to].add(tokenId);
        _tokenOwners.set(tokenId, to);
        emit Transfer(address(0), to, tokenId);
    }
    ...
}
    
    ... 
contract DirtyDogs is ERC721, Ownable {
    ...
    function claimDogs() external {
        uint256 numbersOfTickets = getUserClaimableTicketCount(_msgSender());
        
        for(uint256 i = 0; i < numbersOfTickets; i++) {
            uint256 mintIndex = totalSupply();
            _safeMint(_msgSender(), mintIndex);
        }

        totalClaimed[_msgSender()] = numbersOfTickets.add(totalClaimed[_msgSender()]);
    }

    function getUserClaimableTicketCount(address user) public view returns (uint256) {
        return presaleNumOfUser[user].add(publicNumOfUser[user]).sub(totalClaimed[user]);
    }
    ...
    }
\end{lstlisting} 

\subsection{Properties}
\label{sec:DirtyDogs:Properties}
The attacker could exploit the smart contract due to a vulnerability in the function claimDogs, 
which includes even a bad implementation of the ERC721 standard. It can be classified as a case of reentrancy. 

The NFTs are not directly sold, but a ticket instead is provided to the users, who would convert it. The function claimDogs 
is in charge to verify the tickets and generate the NFTs. Because of the reentrancy, the attacker produced 45 NFTs with a single ticket.

The property can be expressed as a postcondition, which states that the amount of NFTs produced should be equal to the number of tickets of the user. 

We implemented even a support variable called effClaimed, which is increased for every minting, and the totalClaimed instead is updated just at the end of the function. 
The following post-condition is referred to as the vulnerable function claimDogs(...).

\begin{equation}
    \begin{split}
        sum_of_uint(totalClaimed) <= effclaimed
    \end{split}
\end{equation}

\chapter{Analysis Tools}
\label{ch:Tools}

\begin{center}
    

\begin{table*}
    \caption{Tools Classification}
        \label{tab:ToolsClassification}
        \begin{tabular}{ccc}
        \toprule
            Tools with Specifictation & Tools without Specifictation & Tools with Multiple Running Mode \\
            \midrule
            SolcVerify  & Mythril &  Manticore \\
            Celestial & Slither &  SmarTest \\
            Echidna & & \\
            Certora & & \\ 
        \bottomrule
        \end{tabular}
    \end{table*}
\end{center}

This chapter is addressed to present the analysis tools involved in the experiments. 
Each one has a dedicated section, which gives a general overview of its architecture, the implemented methodologies and the limitations. 
We collected the information from their presenting paper or the provided GitHub documentation.

Our work deals with the practical aspect of the tools, their installation and their behaviour in a real-world case, consequently, 
we decided to stress this practical aspect for defining their taxonomy.
We draw it, classifying the tools based on their running mode. \autoref{tab:ToolsClassification} depicts our classification, involving three different subgroups:
\begin{itemize}
    \item tools without specifictation;
    \item tools with specifictation;
    \item tools with multiple running mode.
\end{itemize}
The first one covers the ones which can be run with the source code (or bytecodes) of the smart contract without any additional data. Their strategies can detect a predefined group of vulnerabilities. 
On the other hand, the second group involves the ones which require the user provides specifications for running. The specification can involve a rule to be broken or a property which can be proved or unproved. 
In our taxonomy, the meaning of "multiple mode running" implies the tools which can be run with and without provided specifications. 

The choice of these eight analysis tools is based on our literature research, which encompasses surveys and comparisons of those. 
Another discriminant aspect of the choice is the maintenance of the tools. 
We decided to discard the ones which have not been updated for more than two years. 
We decided to consider just open-source tools because their architecture descriptions and documentation are available. We made an exception in Certora, which is not open source. 
It has the premium version and the free one, we adopted the second one and the free provided documentation online. 

The objectives of the analyses are smart contracts involved in real-world exploits, in most cases, the attackers forced a bug involving the logic of the software itself, 
more than a vulnerability regarding its grammar of it. For this reason, we mostly picked tools which could even have custom specifications.
\section{Tools with multiple mood running}
This section has the aim to describe the tools classified as "with multiple moods running". 
Even other tools have more moods running, but this categorization involves the tools which could take part in the other two subgroups: 
with and without specification.

\subsection{SmarTest}
\label{sec:WithoutSpecification:SmarTest}

SmarTest is a safety analayzer for Ethereum smart contracts develeoped by \citet{SmarTest}. 
It adopts a symbolic execution technique for effectively detecting vulnerable transaction sequences. 
The main challenge of the project involves the tool to find transaction sequences,
revealing the vulnerabilities of the analysed smart contract. Therefore, bugs are discoved as the cause of the interaction of multiple transactions.
The purpose of SmarTest is to automatically deliver vulnerable transaction sequences, 
which demostrate the weaknesses of the smart contract.
The main idea is to build a statistical model using known vulnerable transaction sequences and use it to direct symbolic execution toward 
more successfully detecting unknown vulnerabilities. 
Symbolic execution is guided by statistical language models, so it can prioritize transacion sequences which are likely to reveal vulenrablities.
This statregy involves firstly to run unguided symbolic
execution on existing vulnerable contracts, then to learn a probablity distribution over vulnerable transaction sequences.

The tool is implemented as an extension of VeriSmart (\citet{VeriSmart}).
SmarTest is build on top of that, adding its own functionalities:
\begin{itemize}
    \item symbolic execution with a language model.
    \item Symbolic executor for transaction sequences.
    \item Constraint solving optimization.
\end{itemize}
The installation of VeriSmart is necessary for running the tool. After that, VeriSmart can be used in SmarTest mode.

The report \autoref{lst:SmarTestReport} shows an example of output of SmarTest, which provides the sequence of funtions for exploiting the found bug.
\begin{lstlisting} [caption={SmarTest Example Report.}, label={lst:SmarTestReport}]
    [5] [IO] line 39, (balance[_to] + _value) : disproven, 14.528264s
    1: Example
       {}
       {msg.sender: #x0000000000000000000000000000000000010000,
        msg.value: 0}
    2: approve
       {_spender: #x0000200000000000000000000000000000000000,
        _value: 44365792925664701906080996193724747326645573793336555789802397725137091694592}
       {msg.sender: #x0000000000000000001000000000000000000000,
        msg.value: 0}
    3: mintToken
       {_target: #x0000000000000000001000000000000000000000,
        _amount: 87371285831589357636669861644764241805818792173739087408632338890371299803136}
       {msg.sender: #x0000000000000000000000000000000000010000,
        msg.value: 0}
\end{lstlisting}

The detection of  the following six types of security-critical vulnerabilities are supported by the tool: integer over/underflow, 
assertion violation, division-by-zero, 
ERC20 standard violation, Ether-leaking vulnerability (e.g., 
unauthorized access to transfer), and suicidal vulnerability 
(e.g., unauthorized access to selfdestruct).
In the paper, the authors  focus on just those, without considering vulnerabilities that require analysis of
the interaction of multiple contracts to demonstrate the flaws 
(e.g., reentrancy).

\subsection{Manticore}
\label{sec:Specification:Manticore}
\citet{ManticorePaper} describe in their paper an open-source dynamic
symbolic execution framework called Manticore for analyzing
binaries and Ethereum smart contracts.

The adaptable architecture of Manticore enables it to accommodate both common and uncommon execution contexts, 
and its API enables users to customize their analysis. 

The keyword of this tool is dynamic symbolic execution, which is the implemented analysis technique. 
It examines a state space with a high level of semantic awareness.
Dynamic symbolic execution identifies a collection of path predicates, and constraints on the program's input, 
for paths that the analysis has investigated.
These are employed to produce the programme inputs necessary for the corresponding paths to be followed. 

\autoref{fig:manticore_architecture} provides an overview of Manticore's architecture. The primary
components are the Core Engine and Native and Ethereum
Execution Modules. Secondary components include the Satisfiability Modulo Theories (SMT-LIB) module, Event System,
and API.
\begin{figure}
    \centering
    \includegraphics[width=13cm]{logos/ManticoreArchitecture.pdf}
    \caption{High-level architecture diagram (Figure from \cite{ManticorePaper}).}
    \label{fig:manticore_architecture}
\end{figure}

Manticore's adaptability comes from the Core Engine.
It implements a generic platform-independent symbolic execution engine with few underlying execution model presumptions. 
Despite the differences between  EVM and traditional execution,
Ethereum support did not require substantial architectural
changes to Manticore, since the Core Engine is completely
decoupled from all execution platform details.

Dealing with Symbolic execution of smart contracts, those get input as network transactions consisting of a value and a data buffer, 
containing information about which function should be executed in a contract, and its
arguments.
This technique involves symbolic transactions, where both value and data are symbolic. Symbolic transactions are applied to all Ready states, which
cause the symbolic execution of one transaction. This allows the tool to explore the state space of a contract.
An infinite number of interconnected contracts can be executed in Manticore's emulated environment.
It can monitor the condition of not just a single contract but the entire Ethereum "world," which consists of many interconnected contracts. 

\section{Tools with Specifications}
\label{sec:Tools:Specification}
This section deals with the description of tools with specifications, so the ones which need the source file even additional information. 
Some of the tools requires just some modifications of the source code, on the other hand in some cases the user has to provide an additional file 
providing the specifications.

\subsection{Certora Prover}
\label{sec:Specification:Certora}
Certora Prover is one of the most well-known and used tools for formal verification of Solidity smart contracts. 
Any computer programme that may be compiled using EVM can undergo Certora Prover verifications. 

Since the tool is not open source, we draw the information regarding the tool from the \citetitle{CertoraDocumentation}

It is provided as Software as a Service, a cloud technique, so it is not possible to install the complete tool. A user can interact with it on its 
website, providing the tool as SaaS (service as a Service), 
otherwise, a command-line interface can be downloaded, which interacts with the server by remote. 

The user for the verification has to provide the Solidity file and the specification one, which contains the logic formulas for verification conditions; these are proven by an SMT (satisfiability modulo theories) solver. 
The result is the proof of the rule, otherwise, if the rule is disproved, the solver also provides a concrete test case demonstrating the violation. 

A user can state the specifications as invariants otherwise as functions, called rules.
The invariants contain just a boolean formula.
On the other hand, the rules contain the properties to be proved and these are written like functions. 
For coding these, a similar language to Solidity is used. 
Multiple "require" definitions can be stated at the beginning, for expressing a condition to be realised before the running of it. Functions from the smart contract can be called.
A requirement is that each rule has to conclude with assert, containing a boolean condition. 

\autoref{lst:CertoraCode} covers an example of the specification of the function transferFrom() of a smart contract which implements a token. 
The function cares about the transfer of tokens from one accout to the other one. This rule checks that the balances of the users are updated correctly. 
\begin{lstlisting} [language=Solidity, caption={Certora example specifications}, label={lst:CertoraCode}]

rule transferFromCorrect(address from, address to, uint256 amount) {
    env e;
    require e.msg.value == 0;
    uint256 fromBalanceBefore = balanceOf(from);
    uint256 toBalanceBefore = balanceOf(to);
    uint256 allowanceBefore = allowance(from, e.msg.sender);
    require fromBalanceBefore + toBalanceBefore <= max_uint256;

    transferFrom(e, from, to, amount);

    assert from != to =>
        balanceOf(from) == fromBalanceBefore - amount &&
        balanceOf(to) == toBalanceBefore + amount &&
        allowance(from, e.msg.sender) == allowanceBefore - amount;
}

\end{lstlisting}



\subsection{Celestial}

\label{sec:Specification:Celestial}
\begin{figure}
    \centering
    \includegraphics[width=13cm]{logos/CelestialArchitecture.png}
    \caption{Celestial Architecture}
    \label{fig:celestial_architecture}
\end{figure}

This subsection is addressed to introduce Celestial, 
an analysis tool for Solidity Ethereum-based smart contracts developed by the research team of Microsoft India.
\autoref{fig:celestial_architecture} shows the its architecture. 

The developers provide functional requirements for formally verifying their specifications. The input file is labelled 
It gives programmers the ability to create functional requirements for their contracts. 
The input file is labelled as ".cel", it is the solidity file, with the added specification expressed in notes. 
When the grammar is checked, the contract and the specifications are translated in F* for having the verified verdict. 

\autoref*{lst:CelestialCode} shows an example of input file. The invariants are expressed in a sort of function. 
At the beginning of a function, the specification can be expressed, regarding precondition, postcondition and so on. 
One of these can involve the keyword modifies, which specifies the variable that can be modified in the function, or tx\_reverts, 
which states the possible condition that a function can revert. 
The Solidity implementation of the function is kept.
\begin{lstlisting} [language=Solidity, caption={Celestial example specifications}, label={lst:CelestialCode}]
    contract SimpleMarketplace {
        // contract fields
        invariant balanceAndSellerCredits {
            balance >= totalCredits &&
            totalCredits == sum_mapping ( sellerCredits )
        }
        //function 
        function buy ( address itemId ) public
            modifies [ sellerCredits , totalCredits , itemsToSell ,
            log ]
            tx_reverts !( itemId in itemsToSell ) || value != itemsToSell [ itemId ].price
            || value + totalCredits > uint_max
            post (!( itemId in itemsToSell ) && sellerCredits [ seller ] == old ( sellerCredits ) [seller = > sellerCredits [ seller ] + value ]
            && log == ( eItemSold , sender , itemId ) :: old ( log ) )
         { // implementation of the buy function }
    }
\end{lstlisting}

F* is a fully dependent type system proof helper and programs verification. 
The authors gave the same reasons for involving F* for the formal proof in a blockchain context.
First, it offers SMT-based automation, which is sufficient for the completely automated verification of real-world smart contracts. 
Second, F* enables the developers to work in a customised state and exception effect mimicking the blockchain semantics since it supports user-defined effects. 
Finally, even though we only use its first-order subset with quantifiers and arithmetic, F* permits expressive higher-order specifications.

The celestial process involves 2 steps: the translation of the specification and the verification of F* start. 
The first one involves a python script, on the other hand, the second one entails the installation of F* engine. 
The output covers the response of the verification and a generated solidity file, which represents the smart contract without the specifications notes. 

\paragraph{Limitations} 
The authors explained their tool implementation focused on the Solidity constructs used in their case studies, therefore it does not cover some Solidity cases. 

Delegatecall, embedded assembly
It does not take into account syntactic elements like inheritance, abstract contracts, tuple types, delegatecall and  embedded assembly

Most of these only offer syntactic sugar, which CELESTIAL's future iterations should find simple to support.
Arrays and structs cannot presently be passed as parameters to functions in our implementation. 

Loops are allowed in the smart contracts, however, the tool does not support loop invariants.
When external contracts are called, reentrant behaviour can result, in which the external contract contacts the caller back.
Reasoning about reentrant actions is frequently counterintuitive.
Celestial forbids these actions, this property is called "external callback freedom" (ECF). It states that every callback execution 
in a contract is equivalent to some activity without reentrancy.
So Celestial assumes that there is no callback during the external call.
Programmers can use the tool to create and support the specifications of their contracts without making any assumptions about the behaviour of external contracts. 

\subsection{Echidna}
\label{sec:Specification:Echidna}
Echidna is an open-source smart contract fuzzer, developed by \citet{Echidna}, which makes it easy to automatically generate tests to detect violations in
assertions and custom properties.
Rather than relying on a fixed set of pre-defined bug oracles to detect vulnerabilities
during fuzzing campaigns, Echidna supports three types of proper-
ties: 
\begin{itemize}
    \item user-defined properties (for property-based testing);
    \item assertion checking;
    \item gas use estimation.
\end{itemize}

Figure \autoref{fig:echdina_architecture} depicts the Echidna architecture as a two-step process: pre-processing and fuzzing.
The tool starts with a collection of contracts that have been supplied, as well as attributes that have been integrated into one of the contracts.
Echidna uses Slither, smart contract static analysis framework presented in \autoref{sec:WithoutSpecification:Slither}, to build and analyse the contracts to find relevant constants and functions that directly handle Ether (ETH).
The fuzzing effort begins in the second stage. 
Using the application binary interface (ABI) given by the contract, significant constants stated in the contract, 
and any previously gathered sets of transactions from the corpus, this iterative procedure creates random transactions. 
When a property violation is detected, a counterexample is created to indicate the smallest and most basic sequence of operations that caused the failure. 

\begin{figure}
    \centering
    \includegraphics[width=13cm]{logos/echidna.png}
    \caption{Echidna architecture (image from \cite{Echidna}).}
    \label{fig:echdina_architecture}
\end{figure}

The code \autoref{lst:EchidnaCode} provides an example of invariant in Echdina context. The Solidity contract contains a vulnerability a the backdoor function. 
The output of the terminal presents the subsequence of functions to call for breaking the rule.
\begin{lstlisting} [language=Solidity, caption={Echidna usage example.}, label={lst:EchidnaCode}]
contract Token{
    mapping(address => uint) public balances;
    function airdrop() public{
        balances[msg.sender] = 1000;
    }
    function consume() public{
        require(balances[msg.sender]>0);
        balances[msg.sender] -= 1;
    }
    function backdoor() public{
        balances[msg.sender] += 1;
    }
    function echidna_balance_under_1000() public view returns(bool){
        return balances[msg.sender] <= 1000;
    }
}
\end{lstlisting}

The tool can be even used to test assertions. 
The aim is equivalent of the invariant testing methodology, 
but in this case properties are expressed using the Solidity annotation of assertion. 

\subsection{Solc-Verify}
\label{sec:Specification:Solc-Verify}

\citet{SolcVerify} present Solc-Verify, a source-level verification tool for
Ethereum smart contracts. It takes smart contracts written
in Solidity and discharges verification conditions using modular program
analysis. It is built on top of the Solidity compiler, so it reasons at the level of the contract source code. 
Because of that, Solc-verify can reason about high-level contract attributes 
while accurately modelling low-level language semantics.

Solc-Verify is implemented as an extension to the Solidity compiler.
It accepts a collection of Solidity contracts, including specification annotations, and uses 
the Boogie verifier and SMT solvers to discharge verification conditions. 

As \citet{SolcVerify_2} explain, Solc-verify translates the annotated contracts to the Boogie Intermediate Verification
Language (IVL). The key idea of the translation is to encode state variables as global heaps
and functions as procedures. The tool relies on the Boogie verifier to perform modular
verification by discharging verification conditions to SMT solvers. The verification conditions
encode the function body while assuming the preconditions, and then check if postconditions
hold. In this process, function calls are replaced by their specification and loops by their
invariants (modularity). Finally, the results are back-annotated to the Solidity source.

\autoref{lst:SimpleBank} present an example of annotation, which states that the contract will ensure
that the sum of individual balances is equal to the total balance in the bank.


\begin{lstlisting} [language=Solidity, caption={An example Solidity smart contract implementing a simple bank with SolcVerify annotations.}, label={lst:SimpleBank}]
pragma solidity >=0.7.0;

/**
 * @notice invariant __verifier_sum_uint(balances) <= address(this).balance
 */
contract SimpleBank {
    mapping(address=>uint) balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) public {
        require(balances[msg.sender] > amount);
        bool ok;
        (ok, ) = msg.sender.call{value: amount}(""); // Reentrancy attack
        if (!ok) revert();
        balances[msg.sender] -= amount;
    }
}
\end{lstlisting}

\citet{SolcVerify_3} on GitHub repository, present the specification annotations. Those must be included in special documentation comments (/// or /** */) and must start with the special doctag @notice. 
They must be side-effect free Solidity expressions (with some verifier-specific extensions) and can refer to variables within the scope of the annotated element. Functions cannot be called in the annotations, except for getters.
The currently available annotations are listed below. 

\begin{itemize}
    \item Function pre/postconditions can be attached to functions. Preconditions are assumed before executing the function and postconditions are checked (asserted) in the end. The expression can refer to variables in the scope of the function. The postcondition can also refer to the return value if it is named.
    \item Contract level invariants can be attached to contracts. They are included as both a pre and a postcondition for each public function. The expression can refer to state variables in the contract (and its balance).
    \item Loop invariants can be attached to for and while loops. The expression can refer to variables in the scope of the loop, including the loop counter.
    \item Modification specifiers can be attached to functions. The target can be a (1) state variable, including index and member accesses or (2) a balance of an address in scope. Notes, however, that balance changes due to gas cost or miner rewards are currently not modelled.
    \item Event data specification can be attached to events that should be emitted when certain data changes. 
    Events can declare the state variable(s) they track for changes, or in other words, the variables for which the event should be emitted on a change.
\end{itemize}

\section{Tools without specification}
\label{sec:Tools:WithoutSpecification}
We introduce the second main category of our taxonomy: tools without Specifications.

These do not need any specifications and they based their analyses on preselected strategies. They can be considered "plug \& play", 
indeed they work with code (or even bytecode) of the smart contracts, without the developer should code anything for letting them run. 
Most of the tools that we found during the literary research propose just a warning, depicting the vulnerable lines of code and classifying 
the vulnerability following their taxonomy or open-source ones.


\subsection{Slither}
\label{sec:WithoutSpecification:Slither}
Slither is described by \citet{Slither} as an open-source static analysis framework.
It uses its own intermediate representation, SlithIR, which was created to simplify static analysis of Solidity code. 
Concolic analysis, taint analysis, and control flow checking are involved for detecting a variety
of security vulnerabilities. It is designed to provide
granular information about smart contract code and the flexibility necessary to support many applications.

It is mainly used for:
\begin{itemize}
    \item Automated vulnerability detection: a large variety of
    smart contract bugs can be detected without user inter-
    vention.
    \item Automated optimization detection: Slither detects code
    optimizations that the compiler misses.
    \item Code understanding: printers summarize and display
    contracts' information to aid in the study of the codebase.
    \item Assisted code review: through its API, a user can interact
    with Slither.
\end{itemize}

Slither implements more than twenty bug detectors, regarding reetrancy, Uninitialized variables,
Shadowing and many other. The tool allows the developers to integrate more detectors, therefore it extends Slither's capabilities
to detect more advanced bugs.

\begin{figure}
    \centering
    \includegraphics[width=13cm]{logos/SlitherArchitecture.png}
    \caption{Slither architecture overview (image from \cite{Slither}).}
    \label{fig:slitherarch}
\end{figure}


\citet{SlitherGitHub} is written in python 3 and it is published on GitHub.
During the installation, I did not find any particular issues.

\subsection{Mythril}
\label{sec:WithoutSpecification:Mythril}
Mythril is a security analysis tool for Ethereum smart contracts. It was introduced by \citet{Mythril}.

The tool  relies on taint analysis and control flow checking of the EVM bytecode to
prune the search space and look for values that allow exploiting
vulnerabilities in the smart contract.
It is targeted at finding common vulnerabilities 
and is not able to discover issues in the business logic of an application. \citet{SWCRegistry}'s taxonomy of vulnerabilities is used by Mythril to classify them. 
\autoref{lst:MythrilOutput} illustrates an example of the output of Mythril analysis. 
In the second line, there is a reference to the vulnerability classified by the SWC Registry with the ID of 110 (Assert Violation).

\begin{lstlisting} [caption={Example of the output of Mythril Analysis.}, label={lst:MythrilOutput}]
==== Exception State ====
SWC ID: 110
Severity: Medium
Contract: Token
Function name: transferArray(address[],uint256[])
PC address: 4385
Estimated Gas Usage: 944 - 6585
An assertion violation was triggered.
It is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).
--------------------
In file: test.sol:309

function transferArray(address[] tos, uint256[] values) public returns (bool) {
        for (uint8 i = 0; i < tos.length; i++) {
            require(transfer(tos[i], values[i]));
        }

        return true;
    }

--------------------

\end{lstlisting}